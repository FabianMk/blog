= Conversational software development
Oliver Caldwell
2020-06-07

If you're a seasoned Lisp (or similar) programmer a lot of this will just be rewording of what you already know. If all you've ever known is editing source files and restarting your program this should hopefully be new and inspiring.

Conversational software development is a term I'm half heartedly trying to coin to describe a way to develop your program with an incredibly short feedback loop. It aligns closely with hot module reloading for React based frontend applications but with a much tighter focus and an extra dimension that you may not have seen before.

== Status quo

Most languages require you to make changes to your code (possibly recompile) and then restart your program from the beginning with new instructions. This loop can be so long that you lose track of which change introduced a certain bad behaviour, linting tools will catch some things but others are only apparent after they've been executed.

We have no way to question our program, if we want to see a specific value at a point in time we have to insert multiple log statements and restart it each time until we get the information we need.

This becomes even more difficult if you're working on something side effecting, you end up commenting out a chunk of code so it doesn't execute each time which saves you from resetting a database or state file after every run.

Once you've got the information you need and you've applied your changes you have to undo any changes to the code you made to understand the problem in the first place. Raise your hand if you've ever accidentally committed and pushed log lines or commented out code you were using during development.

Yeah, me too.

== Moving in the right direction

The next step up from this, which only applies to certain contexts such as frontend development, is hot module reloading. This means you don't need to restart your entire application every time you make a change, you write your changes to a file and that file gets loaded in your evaluation environment (usually a browser).

However, hot module reloading needs to be implemented for every language (if it's even possible), it also needs to be tweaked or re-written depending on the context. Hot reloading a React application requires hooking into React to re-render when the file is changed, in a server side node context this will be different. The reloading system _tends_ to be framework specific.

With HMR we can get changes into our program, but it's locked to the granularity of an entire file and it only goes one way. We can't ask the file what a specific value is currently set to. We can't evaluate a single function or method in isolation without evaluating everything surrounding it.

If we need to ask a question we still need to make changes to the source code to add logging and then either restart or poke the program in some other way to get that code to execute.

== Indistinguishable from magic

The tightest feedback loop we can have with our program is the ability to execute an arbitrary string of code and immediately see the result. This is what people mean when they talk about REPL based development, it doesn't have to happen inside a terminal prompt, but it's a good start. The problem with REPL based development is that the name has been complected with terminal based prompt tools (such as when you run `node` or `python` with no arguments in your terminal).

Conversational software development sets the concept free while still describing the core idea: We want to send a question or a statement to our program then listen and respond accordingly. It's a two way street that can go down to a single character of granularity, such as "what's currently in the variable `x`?".

The questions and statements can even be generated by other programs, such as something that looks up documentation or completion results for a given prefix. We can build tooling into our editor that queries our running application through simple snippets of code, let your imagination run wild with the potential of that for a second.

== Conjure

https://github.com/Olical/conjure[Conjure] is my own https://neovim.io/[Neovim] plugin for conversational software development with a variety of languages. At the time of writing it supports https://clojure.org/[Clojure], https://github.com/bakpakin/Fennel[Fennel] (through https://github.com/Olical/aniseed[Aniseed]) and https://janet-lang.org/[Janet] out of the box. I plan on adding support for Racket among other Lisps as well as non-Lisp languages once some more features land in Neovim stable (tree-sitter).

++++
<script id="asciicast-325517" src="https://asciinema.org/a/325517.js" async></script>
++++

I won't be teaching you how to use Conjure specifically here, but you can learn about it through the interactive `:ConjureSchool` once installed or by executing the demo script.

[source,bash]
----
curl -fL https://raw.githubusercontent.com/Olical/conjure/master/scripts/school.sh | bash
----

== Fixing an issue through a conversation

Let's use Conjure and conversational software development to fix an issue with this simple Clojure program.

TODO

== Beyond Conjure

Conjure is my labour of love, I've been writing, rewriting and refining it for years. I think I'm finally at a local maximum with the way it's built and the problems I'm trying to solve.

I hope it proves extremely useful for you in your personal and work projects. If you aren't interested in Conjure or the languages it supports I hope you can at least take the ideas of conversational software development with you.

Spread these ideas and build more tools that embody them, let's shorten the feedback loop in editing source code to be effectively non-existent. I'd love to hear your thoughts on this topic, please do get in touch using the details in the footer.
